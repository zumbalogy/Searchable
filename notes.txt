
One potential future feature (besides more customizable syntax and all)
would be to be able to specify a certain number of matches. like,
this name field must have the string ":)" 3 times. having
an option to pass though to real regexes might solve this.

right now, there are likely issues with comparing dates.

right now there will be issues with 'foo:-bar'.

it might be good to have a way to tell "collection" types (paren, or, minus)
from other nest types (compare and command) in the ast, to avoid code like

     [:paren, :pipe, :minus].include?(x[:nest_type])

TODO: it could be nice to be able to have an alias where the proper
name is off limits.

Note: in example project, have a "sort by" example

Note: it should also have a way to test presence of something that
is also searchable as a string. so, as an example, "error:'not found'|error:false"
or some such could work.

TODO: support arrays (and maybe other nesting/relations)

Right now, a blindspot if you want to search 'foo:"tRue"' and have have tRue not
be case sensitive. (since quotes are used to escape from true part if thats enabled
but also used to preserve case)


Search across fields
ann
ann orange

Search specific values and fields
"Ann"
color:orange

Use aliases
favorite_color:orange
color:red
(maybe do points/score)

Check booleans and existence
admin:true
score:false

Match with logical ORs
red|blue
red|blue|bob

Match with logical NOTs
-red
-(red|blue)
(green admin) | john

Search ranges and dates (via the Chronic Gem)
score<=100
born>today
a<b<c

----------

chronic thinks that "2000" means 20:20 today, not year 2000.
also it would be nice if "monday" matched any date on a monday, not just like this monday.
 -- for command at least (maybe compare it makes less sense)

--------------------------------
--------------------------------


--------------------------------
--------------------------------


"hello"
{general_search: "hello"}
{or => {foo => /hello/}, {bar => /hello/}}

"-hello"
{general_search: "hello", negate: true}
{and => {foo.not => /hello/}, {bar.not => /hello/}}

"red blue"
{type: and, nest: [{general_search: "red"}, {general_search: "blue"}]
{and =>
  {or => {foo => /red/}, {bar => /red/}}
  {or => {foo => /blue/}, {bar => /blue/}}}

"red|blue"
{type: or, nest: [{general_search: "red"}, {general_search: "red"}]}
{or =>
  {or => {foo => /red/}, {bar => /red/}}
  {or => {foo => /blue/}, {bar => /blue/}}}
# and this could be optomized to a single OR with 4 possibilities

"(A|B) (C|D)"
{type: and, nest: [{type: or, nest: [{general_search: "A"}, {general_search: "B"}]}
                   {type: or, nest: [{general_search: "C"}, {general_search: "D"}]}]
{and =>
  {or =>
     {or => {foo => /A/}, {bar => /A/}}
     {or => {foo => /B/}, {bar => /B/}}}
  {or =>
     {or => {foo => /C/}, {bar => /C/}}
     {or => {foo => /D/}, {bar => /D/}}}S


"(A|B)|(C|D)" -> "A|B|C|D"
"(A B) (C D)" -> "A B C D"

"(A B)|(C D)"
{type: or, nest: [{type: and, nest: [{general_search: "A"}, {general_search: "B"}]},
                  {type: and, nest: [{general_search: "C"}, {general_search: "D"}]}]}
{and =>
  {or =>
     {or => {foo => /A/}, {bar => /A/}}
     {or => {foo => /B/}, {bar => /B/}}}
  {or =>
     {or => {foo => /C/}, {bar => /C/}}
     {or => {foo => /D/}, {bar => /D/}}}}

"hi|-lo red:red 'fo ba' re>=da"
["hi|-lo", "red:ded", "'fo ba'", "re>=da"]
[["hi", "|", "-lo"], ["red:ded"], ["fo ba"], ["re", ">=", "da"]]
[["hi", "|", ["-", "lo"]], ["red:ded"], ["fo ba"], ["re", ">=", "da"]]

"hi|-lo red:red 'fo ba' re>=da"
[{:type=>:or,
  :nest=>
   [{:type=>:general, :search=>"hi"},
    {:type=>:not, :nest=>[{:type=>:general, :search=>"lo"}]}]},
 {:type=>:compare, :search=>"red:red"},
 {:type=>:general, :search=>"'fo ba'"},
 {:type=>:command, :search=>"re>=da"}]

# this syntax is now not allowed as a negation.
# it would make having negative values hard to look for.
# split_parts("foo:-bar")
